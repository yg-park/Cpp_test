	<8장 - 상속>
객체 사이에는 상속 관계가 없음
기본(부모) 클래스의 속성과 기능을 파생(자식) 클래스에 물려주는 것
/*
휴대폰만들기
1. 리눅스BSP : boot loader(임베디드, flash rom에 들어있음/pc는 bios) 킬때 
	      검사후 os적재
	      -RAM(메모리), 그래픽카드 2개가 없으면 부팅x
2. 리눅스Kernel(임베디드/pc는 command.com)
3. 파일 시스템(Android, ios, ../pc는 windows.com) - 화면(인터페이스)관리 담당

boot loader+kernel -> firm ware : 우리가 주로 할 것
*/
상속의 목적 및 장점
1. 간결한 클래스 작성 - 클래스 기능 물려받음
2. 클래스간 분류 및 관리 용이 - 클래스들의 관계 파악 용이
3. 소프트웨어 생산성 향상

업 캐스팅 : 파생 클래스 포인터가 기본 클래스 포인터에 치환되는 것
자식 클래스의 것을 부모 클래스에 붙인다
잘 안쓰임 실습도 하지말기

다운 캐스팅 : 반대, 오류없음

protected
선언된 클래스에서 접근 가능
파생된 클래스에서만 접근 허용
public : 파생클래스에서'만' 접근

부모 클래스 생성자 > 자식 클래스 생성자
 > 자식 클래스 생성자 소멸 > 부모 클래스 생성자 소멸(소멸은 역순)

기본 클래스에 기본생성자가 없으면 파생 클래스의 기본생성자가 작동x

상속지정
기본 클래스의 멤버의 접근 속성을 어떻게 계승할지 지정 가능
일반적으로 public, protected로 받는다
(private면 자신도 사용하지 못하기 때문에)


다중상속

가상상속
virtual로 중복상속 해결
중복이면 하나만 생성하란 뜻

	<9장 - 가상 함수와 추상 클래스>
가상 함수
{ virtual void f(); }

오버라이딩
파생 클래스에서 기본 클래스의 가상함수와 동일한 이름의 함수 선언
함수재정의, 다형성
virtual는 보통 기본 클래스에 붙인다
애매하면 모두 붙이고 호출할 때 파생 클래스의 함수가 실행된다
가상 함수 이름, 매개변수 타입, 개수, 리턴 타입이 일치해야함
파생 클래스에서 virtual 생략 가능
사용할 함수를 가장 마지막에 놓으면 된다

동적 바인딩
파생 클래스에 대해
/*
MFC 는 순서가 중요하다
ui - 함수 - 연결 - 코딩
만약 안되면 모두 없애고 다시 하는 것이 빠르다
*/
범위 지정 연산자 ::
기본클래스::가상함수() 형태

가상 소멸자

오버라이딩과 함수재정의 차이
오버라이딩은 virtual을 붙일 때 자식 클래스를 무조건 실행
함수 재정의는 가장 가까운 함수를 실행

기본클래스의 포인터

순수 가상 함수
virtual void draw() = 0; 으로 선언
기본 클래스의 가상함수는 파생 클래스에서 오버라이딩된 함수를 알려주는 역할
코드가 없고 선언만 있음, 안씀

추상 클래스
최소한 하나의 순수 가상 함수를 가진 클래스
온전한 클래스가 아니므로 객체 생성 불가능
포인터는 선언 가능
상속에서 기본 클래스의 역할을 하기 위함(인터페이스)
캡슐화하여 보안을 위해 사용

	<10장 - 템플릿과 표준 템플릿 라이브러리(STL)>
제네릭(일반화) : 함수 클래스 일반화하고 코드를 생산
템플릿 : 함수, 클래스를 일반화하는 틀
잘 사용하지는 않음
template <class T>
void myswap (T&a, T&b) {
     T tmp;
     tmp = a;
     a = b;
     b = temp;
}
두 매개 변수의 타입이 다르면 불가능
장점
-함수 코드의 재사용
단점
-컴파일러에 따라 지원하지 않을 수 있다(리눅스)

STL
컨테이너 형태로 리스트 큐 스택 맵 셋 벡터를 담아두는 클래스

벡터 컨테이너
가변 길이 배열 구현
저장 삭제 검색 등 함수 지원
원소는 인덱스 (0부터 시작)접근 가능
/*
자료구조
연결형 : 포인터로 다름 배열을 가리킴
이중연결 : 양쪽포인터
*/
iterator
반복자
컨테이너의 원소를 가리키는 포인터

맵
키, 값의 쌍을 원소로 저장하는 제네릭 컨테이너
두개씩 할때는 맵이 편하다

알고리즘 함수
iteratot it : 위치
it : 몇번째인지

auto
복잡한 변수선언을 간소화
긴 타입 선언 시 오타 최소화
자동으로 타입을 맞춰준다
의도와 다르게 될 수 있으므로 자제하기바람

람다식
수학함수를 단순하게 표현
c에는 잘 맞지 않음
캡쳐 리스트 / 매개변수 리스트 / 리턴타입 / 함수바디 의 형태

for_each
컨테이너의 각 원소를 검색하는 함수 (집합 명령)
/*
in DB, 숫자 = 문자
*/

	<11장 - c++ 입출력 시스템>
stream
데이터 흐름
버퍼를 가진다
키 입력 스트림 : 입력줄 수정되어 엔터 누르면 끝나고 프로그램으로 들어감
입출력 방식 2개
1. 스트림 입출력
   스트림 버퍼에 저장되고 엔터 누르면 버퍼를 읽으며 출력
2. raw level console
   키가 입력되는 즉시 키 값 전달
   호환성 낮음

ostream에서
cout.put, cout.write 이용

istream에서
get
EOF : ctrl z

포맷 입출력
printf와 유사
사용이 끝나면 초기화
unsetf > setf > unset

포맷함수 -> 그나마 쓰고 사실 다 잘 안씀
width 공백 수
fill 채우기
precision(n) n 번째 자리에서 반올림

조작자
std:: 없어도 가능하다
필요하면 iomanip 입력














